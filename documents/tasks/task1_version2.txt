Task : Write a pseudo code to give the list of users who played the game n consecutive days atleast once.

Algo:
INPUT : JSON file containing session objects(represented by 'A')
OUTPUT : List of users appearing atleast once for n consecutive days.(Represented by the stack 'Solution')

Stack[] represents the array of stacks for each unique user
BaseSession[] = represents an array which stores the base time of each user appearance.
'A' contains the list of all apprearacnes of all the users (assuming that they are sorted according to date)
There should be a minimum session gap of 'x' hours to be considered as two different days.

session object format => { user_id:'***',starttime:'***',duration:'***'....}

    Let the JSON object be A
    for i = 1 --> sizeof(A)
      if(stack[A[i].userid].size() == n)    //if user has already appeared for n days in a row,
      {
          continue                          //ignore since he is already accounted for
      }
      else
      {
          if(stack[A[i].userid].size() == 0)  //first appearance
          {
              stack[A[i].userid].push(A[i])   //push user onto the corresponding stack
              BaseSession[A[i].userid] = A[i]; // storing the base session details which will be taken as reference in the future.
          }
          else
          {
              if(stack[A[i].userid].top().time +24 >= A[i].time)  // If the time gap between the top of the stack and A[i] is less than 24 hours
              {
                  if(if the number of days between A[i] and the basesession is same as the size of stack)
                  {
                    stack[A[i].userid].pop();              //pop the top element of the stack and push the latest session of the day.
                    stack[A[i].userid].push(A[i]);
                  }
                  else if(if the number of days between A[i] and the basessesion is one more than the size of stack)
                  {
                   // to consider 2 session taking place in 2 different days, there should be a minimum session gap
                      if(A[i].time-stack[A[i].userid].top().time>=SESSION_GAP)
                      {
                        stack[A[i].userid].push(A[i]);         // if the time is greater than session gap,then push the session onto the stack.
                        if(stack[A[i].userid].size() == n)    //if user has now appeared for n days in a row
                        {
                            Solution.push(A[i].userid)           //push user onto the solution stack
                        }
                      }
                  }
              }
              else if(stack[A[i].userid].top().date + 24 <= A[i].date <= stack[A[i].userid].top().date + 48) //if the user appears on the next day
              {
                  // if the time difference between A[i] and the top of the stack is greater than 24 hours and less than 48 hours, push it onto the stack
                  stack[A[i].userid].push(A[i])             //push user onto the stack
                      if(stack[A[i].userid].size() == n)    //if user has now appeared for n days in a row
                      {
                          Solution.push(A[i].userid)           //push user onto the solution stack
                      }
              }
              else if(A[i].date > stack[A[i].userid].top().date + 48)  //if user takes more than 1 day to appear
              {
                  // if the time difference between  any 2 sessions is greater than 48 hours, simple empty the stack and push the present session which is the base session now.
                  stack[A[i].userid].empty()                  //empty the previous contents of his stack
                  stack[A[i].userid].push(A[i])       //push the new appearance onto his stack
                  BaseSession[A[i].userid] = A[i]
              }
          }
      }

