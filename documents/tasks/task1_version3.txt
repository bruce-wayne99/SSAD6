Task : Write a pseudo code to give the list of users who played the game n consecutive days atleast once.

session object format => { user_id:'***',starttime:'***',duration:'***',....}

FetchDataOfEachUser(SessionData)
{
    UserData = {};
    Iterator = 0;
    while(Iterator < SessionData.length())
    {
    if(SessionData[iterator].user_id in C)
    {
        Userdata[SessionData[Iterator].user_id].push(SessionData[iterator]);           //Attributes of object are userid's and each attribute holds an array of sessions.
}
Else
{
    Userdata[SessionData[iterator].user_id] = [ ];
    Userdata[SessionData[iterator].user_id].push(SessionData[iterator]);
        Iterator++;
    }
    return UserData;
}
OnTheSameDay(UserData, SessionGap, n, BaseEntry, stack)
{
    if((DaysGap Between UserData[iterator] and BaseEntry) == stack.length() - 1)       //consider the latest appearance if he comes on the same day.
    {
        stack.pop();
        stack.push(UserData[iterator]);
    }
    else if((DaysGap Between UserData[Iterator] and BaseEntry) == stack.length)        //a newday as considered from base case push it if difference is more than the session gap
    {
        if(UserData[Iterator].time - stack.top().time >= SessionGap)
        {
            stack.push(UserData[Iterator]);
        }
    }
    return stack;
}
ProcessDataOfUser(UserData, SessionGap, n)
{
    stack = [];
    Iterator = 0;
    BaseEntry;
    while(Iterator < UserData.length())
    {
      if(stack.length() == n)
      {
          return 1;               //if the stack size becomes the required no of consecutive days       }
      if(stack.length() == 0)
      {
          stack.push(UserData[Iterator]);
          BaseEntry = UserData[Iterator];        //first appearance
      }
      else if(stack.top().time +24 >= UserData[Iterator].time)
      {
          stack = OnTheSameDay(UserData[Iterator], SessionGap, n, BaseEntry, stack);       //The user appeared on the sameday, function is called to whether consider it or not.
      }
      else if(stack.top().time + 24 <= UserData[Iterator].time <= stack.top().time + 48)
      {
          stack.push(UserData[Iterator]);                                                //User appeared on the next day push it.
      }
      else
      {
          stack.empty();                      //Other wise start fresh by emptying the stack
          stack.push(UserData[Iterator]);
          BaseEntry = UserData[Iterator];
      }
      Iterator++;
    }

    if(UserData.length() == n)
        return 1;
    else
        return 0;
}
main()
{
    SessionData = FetchDataFromApplication();       //A is an object containing the session objects.
    NoOfSessions = SessionData.length();
    UsersConsidered = [];                 //Gives the list of Users Whose Data is already fetched.
    SessionGap = 2;                       //SessionGap indicates the minimum time game to be present between to consecutive entries in the stack.
    NoOfConsecutiveDays = 5;              //Assuming the number of Consecutive Days for the given task to be 5
    C = FetchDataOfEachUser(SessionData);
    for UserData in C
    {
        IsActiveUser = ProcessDataOfUser(UserData , SessionGap , NoOfConsecutiveDays);     //return value of the function indicates whether the user appeared for given consecutive days.
        if(IsActiveUser == 1)
        {
            SolutionIds.push(UserData);           //SolutionIds is the output array containing the userids.
        }
    }
    return SolutionIds;
}
